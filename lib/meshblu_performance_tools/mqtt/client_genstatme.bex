# defmodule MeshbluPerformanceTools.MQTT.Client do
#   @behaviour :gen_statem
#   # use GenStateMachine #, callback_mode: :state_functions
#   def callback_mode, do: :state_functions

#   require Logger
#   require IEx

#   def start_link(args \\ [host: "localhost", port: 1883, uuid: "47706d7d-a6db-4edd-b7a1-f7aebc5bef4e", token: "e6869b631aa3d521a842752f8ed7300d62fa9332"]) do
#     Logger.info "start mqtt...................."
#     # GenStateMachine.start_link(__MODULE__, {:event, args})
#     :gen_statem.start(__MODULE__, args, [])
#   end

#   def init(args), do: {:ok, :event, args}

#   def process(pid) do
#     :gen_statem.cast(pid, :process)
#   end

#   def get_state(pid) do
#     :gen_statem.call(pid, :state)
#   end

#   def event(:cast, :process, state) do
#     {:ok, pid } = MeshbluPerformanceTools.MQTT.Process.start_link(self(), [host: state[:host], port: state[:port], username: state[:uuid], password: state[:token]])
#     {:next_state, :subscribe, state ++ [pid: pid]}
#   end

#   def event(event_type, event_content, data) do
#     handle_event(event_type, event_content, data)
#   end

#   def subscribe(:cast, :process, state) do
#     IEx.pry
#     pid = state[:pid]
#     MeshbluPerformanceTools.MQTT.Process.sub(pid, "47706d7d-a6db-4edd-b7a1-f7aebc5bef4e", 0)
#     {:next_state, :ok, state}
#   end

#   def subscribe(event_type, event_content, data) do
#     handle_event(event_type, event_content, data)
#   end

#   def ok(:cast, :process, state) do
#     {:next_state, :ok, state}
#   end 
  
#   def ok(event_type, event_content, data) do
#     handle_event(event_type, event_content, data)
#   end


#   def handle_event({:call, from}, :state, state) do
#     {:keep_state_and_data, [{:reply, from, state}]}
#   end


#   # def terminate(_reason, _state, _data), do: :void

#   # def code_change(_vsn, state, data, _extra), do: {:ok, state, data}

#   # def handle_event(:cast, :start, :off, data) do
#   #   {:next_state, :on, data + 1}
#   # end

#   # def handle_event(:cast, :flip, :on, data) do
#   #   {:next_state, :, data}
#   # endt

#   # def handle_event({:call, from}, :get_count, state, data) do
#   #   {:next_state, state, data, [{:reply, from, data}]}
#   # end

#   # def handle_event(event_type, event_content, state, data) do
#   #   # Call the default implementation from GenStateMachine
#   #   super(event_type, event_content, state, data)
#   # end

 

#   # def subscribe(:next , _from, state) do
#   #   :ok
#   # end
  
#   # def handle_cast({:client, uuid, token}, state) do
#   #   {:ok, pid} = MeshbluPerformanceTools.MQTT.Process.start_link(self(), [host: info[:host], port: info[:port], username: uuid, password: token])
#   #   MeshbluPerformanceTools.MQTT.Process.sub(pid, uuid, 0)
#   #   {:noreply, state }
#   # end

#   # def client(pid, uuid, token) do
#   #   GenServer.cast(pid, {:client, uuid, token})
#   # end

#   # # def handle_call({:client, uuid, token}, _from, state) do
#   # #   info = elem(state,0)
#   # #   {:ok, pid} = MeshbluPerformanceTools.MQTT.Process.start_link(self(), [host: info[:host], port: info[:port], username: uuid, password: token])
#   # #   MeshbluPerformanceTools.MQTT.Process.sub(pid, uuid, 0)
#   # #   {:reply, MeshbluPerformanceTools.MQTT.Process.sub(pid, uuid, 0), state}
#   # # end

#   # def handle_info(msg, state) do
#   #   IO.puts "Received in info: #{msg}"
#   #   IO.inspect state
#   #   {:noreply, state}
#   # end
  
# end